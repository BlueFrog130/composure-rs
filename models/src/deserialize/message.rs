use core::str;

use serde::{Deserialize, Deserializer};
use serde_repr::Deserialize_repr;

use crate::{
    common::Snowflake,
    deserialize::{
        Application, Channel, ChannelType, Embed, Emoji, Interaction, Role, RoleSubscriptionData,
        StickerItem, User,
    },
};

/// [Message Structure](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-object-message-structure)
#[derive(Debug, Deserialize)]
pub struct Message {
    /// id of the message
    pub id: Snowflake,

    /// id of the channel the message was sent in
    pub channel_id: Snowflake,

    /// the author of this message (not guaranteed to be a valid user, see below)
    pub author: User,

    /// contents of the message
    pub content: String,

    /// when this message was sent
    pub timestamp: String,

    /// when this message was edited (or null if never)
    pub edited_timestamp: Option<String>,

    /// whether this was a TTS message
    pub tts: bool,

    /// whether this message mentions everyone
    pub mention_everyone: bool,

    /// users specifically mentioned in the message
    pub mentions: Vec<User>,

    /// roles specifically mentioned in this message
    pub mention_roles: Vec<Role>,

    /// channels specifically mentioned in this message
    pub mention_channels: Option<Vec<ChannelMention>>,

    /// any attached files
    pub attachments: Vec<Attachment>,

    /// any embedded content
    pub embeds: Vec<Embed>,

    /// reactions to the message
    pub reactions: Option<Vec<Reaction>>,

    // /// used for validating a message was sent
    // pub nonce: Option<todo>,
    /// whether this message is pinned
    pub pinned: bool,

    /// if the message is generated by a webhook, this is the webhook's id
    pub webhook_id: Option<Snowflake>,

    /// [type of message](https://discord.com/developers/docs/resources/channel#message-object-message-types)
    #[serde(rename = "type")]
    pub t: MessageType,

    /// sent with Rich Presence-related chat embeds
    pub activity: Option<MessageActivity>,

    /// sent with Rich Presence-related chat embeds
    pub application: Option<Application>,

    /// if the message is an [Interaction](https://discord.com/developers/docs/interactions/receiving-and-responding) or application-owned webhook, this is the id of the application
    pub application_id: Option<Snowflake>,

    /// data showing the source of a crosspost, channel follow add, pin, or reply message
    pub message_reference: Option<MessageReference>,

    /// [message flags](https://discord.com/developers/docs/resources/channel#message-object-message-flags) combined as a [bitfield](https://en.wikipedia.org/wiki/Bit_field)
    pub flags: Option<u32>,

    // /// the message associated with the message_reference
    // pub referenced_message: Option<Message>,
    /// sent if the message is a response to an [Interaction](https://discord.com/developers/docs/interactions/receiving-and-responding)
    pub interaction: Option<Interaction>,

    /// the thread that was started from this message, includes [thread member](https://discord.com/developers/docs/resources/channel#thread-member-object) object
    pub thread: Option<Channel>,

    /// sent if the message contains components like buttons, action rows, or other interactive components
    pub components: Option<Vec<Component>>,

    /// sent if the message contains stickers
    pub sticker_items: Option<Vec<StickerItem>>,

    /// A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with total_message_sent on parent thread
    pub position: Option<i32>,

    /// data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message
    pub role_subscription_data: Option<RoleSubscriptionData>,
}
/// [Channel Mention Object](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#channel-mention-object)
#[derive(Debug, Deserialize)]
pub struct ChannelMention {
    /// id of the channel
    pub id: Snowflake,

    /// id of the guild containing the channel
    pub guild_id: Snowflake,

    /// the [type of channel](https://discord.com/developers/docs/resources/channel#channel-object-channel-types)
    #[serde(rename = "type")]
    pub t: i32,

    /// the name of the channel
    pub name: String,
}

/// [Attachment Object](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#attachment-object)
#[derive(Debug, Deserialize)]
pub struct Attachment {
    /// attachment id
    pub id: Snowflake,

    /// name of file attached
    pub filename: String,

    /// description for the file (max 1024 characters)
    pub description: Option<String>,

    /// the attachment's [media type](https://en.wikipedia.org/wiki/Media_type)
    pub content_type: Option<String>,

    /// size of file in bytes
    pub size: u32,

    /// source url of file
    pub url: String,

    /// a proxied url of file
    pub proxy_url: String,

    /// height of file (if image)
    pub height: Option<u32>,

    /// width of file (if image)
    pub width: Option<u32>,

    /// whether this attachment is ephemeral
    pub ephemeral: Option<bool>,

    /// the duration of the audio file (currently for voice messages)
    pub duration_secs: Option<f32>,

    /// base64 encoded bytearray representing a sampled waveform (currently for voice messages)
    pub waveform: Option<String>,
}

/// [Reaction Object](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#reaction-object)
#[derive(Debug, Deserialize)]
pub struct Reaction {
    /// times this emoji has been used to react
    pub count: i32,

    /// whether the current user reacted using this emoji
    pub me: bool,

    /// emoji information
    pub emoji: Emoji,
}

/// [Message Types](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-object-message-types)
#[derive(Debug, Deserialize_repr)]
#[repr(u8)]
pub enum MessageType {
    /// true
    Default = 0,

    /// false
    RecipientAdd = 1,

    /// false
    RecipientRemove = 2,

    /// false
    Call = 3,

    /// false
    ChannelNameChange = 4,

    /// false
    ChannelIconChange = 5,

    /// true
    ChannelPinnedMessage = 6,

    /// true
    UserJoin = 7,

    /// true
    GuildBoost = 8,

    /// true
    GuildBoostTier1 = 9,

    /// true
    GuildBoostTier2 = 10,

    /// true
    GuildBoostTier3 = 11,

    /// true
    ChannelFollowAdd = 12,

    /// false
    GuildDiscoveryDisqualified = 14,

    /// false
    GuildDiscoveryRequalified = 15,

    /// false
    GuildDiscoveryGracePeriodInitialWarning = 16,

    /// false
    GuildDiscoveryGracePeriodFinalWarning = 17,

    /// true
    ThreadCreated = 18,

    /// true
    Reply = 19,

    /// true
    ChatInputCommand = 20,

    /// false
    ThreadStarterMessage = 21,

    /// true
    GuildInviteReminder = 22,

    /// true
    ContextMenuCommand = 23,

    /// true*
    AutoModerationAction = 24,

    /// true
    RoleSubscriptionPurchase = 25,

    /// true
    InteractionPremiumUpsell = 26,

    /// true
    StageStart = 27,

    /// true
    StageEnd = 28,

    /// true
    StageSpeaker = 29,

    /// true
    StageTopic = 31,

    /// false
    GuildApplicationPremiumSubscription = 32,
}

/// [Message Activity Structure](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-object-message-activity-structure)
#[derive(Debug, Deserialize)]
pub struct MessageActivity {
    /// [type of message activity](https://discord.com/developers/docs/resources/channel#message-object-message-activity-types)
    #[serde(rename = "type")]
    pub t: MessageActivityType,

    /// party_id from a [Rich Presence event](https://discord.com/developers/docs/rich-presence/how-to#updating-presence-update-presence-payload-fields)
    pub party_id: Option<String>,
}

/// [Message Activity Types](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-object-message-activity-types)
#[derive(Debug, Deserialize_repr)]
#[repr(u8)]
pub enum MessageActivityType {
    Join = 1,

    Spectate = 2,

    Listen = 3,

    JoinRequest = 5,
}

/// [Message Flags](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-object-message-flags)
#[derive(Debug, Deserialize_repr)]
#[repr(u16)]
pub enum MessageFlags {
    /// this message has been published to subscribed channels (via Channel Following)
    Crossposted = 1 << 0,

    /// this message originated from a message in another channel (via Channel Following)
    IsCrosspost = 1 << 1,

    /// do not include any embeds when serializing this message
    SuppressEmbeds = 1 << 2,

    /// the source message for this crosspost has been deleted (via Channel Following)
    SourceMessageDeleted = 1 << 3,

    /// this message came from the urgent message system
    Urgent = 1 << 4,

    /// this message has an associated thread, with the same id as the message
    HasThread = 1 << 5,

    /// this message is only visible to the user who invoked the Interaction
    Ephemeral = 1 << 6,

    /// this message is an Interaction Response and the bot is "thinking"
    Loading = 1 << 7,

    /// this message failed to mention some roles and add their members to the thread
    FailedToMentionSomeRolesInThread = 1 << 8,

    /// this message will not trigger push and desktop notifications
    SuppressNotifications = 1 << 12,

    /// this message is a voice message
    IsVoiceMessage = 1 << 13,
}

/// [Message Reference Structure](https://discord.comundefinedhttps://discord.com/developers/docs/resources/channel#message-reference-object-message-reference-structure)
#[derive(Debug, Deserialize)]
pub struct MessageReference {
    /// id of the originating message
    pub message_id: Option<Snowflake>,

    /// id of the originating message's channel
    pub channel_id: Option<Snowflake>,

    /// id of the originating message's guild
    pub guild_id: Option<Snowflake>,

    /// when sending, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true
    pub fail_if_not_exists: Option<bool>,
}

#[derive(Debug)]
pub struct ComponentType<const T: u8>;

impl<'de, const T: u8> Deserialize<'de> for ComponentType<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = u8::deserialize(deserializer)?;
        if value == T {
            Ok(ComponentType::<T>)
        } else {
            Err(serde::de::Error::custom("not a component type"))
        }
    }
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum Component {
    ActionRow(ActionRow),
    Button(ButtonComponent),
    StringSelect(SelectMenu<3>),
    TextInput(TextInput),
    UserSelect(SelectMenu<5>),
    RoleSelect(SelectMenu<6>),
    MentionableSelect(SelectMenu<7>),
    ChannelSelect(SelectMenu<8>),
}

#[derive(Debug, Deserialize)]
pub struct ActionRow {
    #[serde(rename = "type")]
    pub t: ComponentType<1>,

    pub components: Vec<Component>,
}

#[derive(Debug, Deserialize)]
pub struct ButtonComponent {
    #[serde(rename = "type")]
    pub t: ComponentType<2>,

    /// Button style
    pub style: ButtonStyle,

    /// Text that appears on the button; max 80 characters
    pub label: Option<String>,

    /// name, id, and animated
    pub emoji: Option<Emoji>,

    /// Developer-defined identifier for the button; max 100 characters
    pub custom_id: Option<String>,

    /// URL for link-style buttons
    pub url: Option<String>,

    /// Whether the button is disabled (defaults to false)
    pub disabled: Option<bool>,
}

#[derive(Debug, Deserialize_repr)]
#[repr(u8)]
pub enum ButtonStyle {
    /// Blurple
    Primary = 1,

    /// Grey
    Secondary = 2,

    /// Green
    Success = 3,

    /// Red
    Danger = 4,

    /// Grey, navigates to URL
    Link = 5,
}

/// [Select Menu Structure](https://discord.comundefinedhttps://discord.com/developers/docs/interactions/message-components#select-menu-object-select-menu-structure)
#[derive(Debug, Deserialize)]
pub struct SelectMenu<const T: u8> {
    /// [Type](https://discord.com/developers/docs/interactions/message-components#component-object-component-types) of select menu component (text: 3, user: 5, role: 6, mentionable: 7, channels: 8)
    #[serde(rename = "type")]
    pub t: ComponentType<T>,

    /// ID for the select menu; max 100 characters
    pub custom_id: String,

    /// Specified choices in a select menu (only required and available for string selects (type 3); max 25
    pub options: Option<Vec<SelectOption>>,

    /// List of channel types to include in the channel select component (type 8)
    pub channel_types: Option<Vec<ChannelType>>,

    /// Placeholder text if nothing is selected; max 150 characters
    pub placeholder: Option<String>,

    /// Minimum number of items that must be chosen (defaults to 1); min 0, max 25
    pub min_values: Option<i32>,

    /// Maximum number of items that can be chosen (defaults to 1); max 25
    pub max_values: Option<i32>,

    /// Whether select menu is disabled (defaults to false)
    pub disabled: Option<bool>,
}

/// [Select Option Structure](https://discord.comundefinedhttps://discord.com/developers/docs/interactions/message-components#select-menu-object-select-option-structure)
#[derive(Debug, Deserialize)]
pub struct SelectOption {
    /// User-facing name of the option; max 100 characters
    pub label: String,

    /// Dev-defined value of the option; max 100 characters
    pub value: String,

    /// Additional description of the option; max 100 characters
    pub description: Option<String>,

    /// id, name, and animated
    pub emoji: Option<Emoji>,

    /// Will show this option as selected by default
    pub default: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct TextInput {
    #[serde(rename = "type")]
    pub t: ComponentType<4>,

    /// Developer-defined identifier for the input; max 100 characters
    pub custom_id: String,

    /// The [Text Input Style](https://discord.com/developers/docs/interactions/message-components#text-inputs-text-input-styles)
    pub style: TextInputStyle,

    /// Label for this component; max 45 characters
    pub label: String,

    /// Minimum input length for a text input; min 0, max 4000
    pub min_length: Option<i32>,

    /// Maximum input length for a text input; min 1, max 4000
    pub max_length: Option<i32>,

    /// Whether this component is required to be filled (defaults to true)
    pub required: Option<bool>,

    /// Pre-filled value for this component; max 4000 characters
    pub value: Option<String>,

    /// Custom placeholder text if the input is empty; max 100 characters
    pub placeholder: Option<String>,
}

/// [Text Input Styles](https://discord.comundefinedhttps://discord.com/developers/docs/interactions/message-components#text-inputs-text-input-styles)
#[derive(Debug, Deserialize_repr)]
#[repr(u8)]
pub enum TextInputStyle {
    /// Single-line input
    Short = 1,

    /// Multi-line input
    Paragraph = 2,
}

#[cfg(test)]
pub mod tests {
    use super::*;

    #[test]
    pub fn button_component() {
        let json = r#"{
            "type": 1,
            "components": [
                {
                    "type": 2,
                    "label": "Click me!",
                    "style": 1,
                    "custom_id": "click_one"
                }
            ]
        }"#;

        let res = serde_json::from_str::<Component>(json);

        assert!(res.is_ok());

        let component = res.unwrap();

        assert!(matches!(component, Component::ActionRow { .. }));

        match component {
            Component::ActionRow(action_row) => {
                assert_eq!(action_row.components.len(), 1);
                assert!(matches!(action_row.components[0], Component::Button { .. }));
            }
            _ => assert!(false),
        }
    }

    #[test]
    pub fn select_menu_component() {
        let json = r#" {
            "type": 1,
            "components": [
                {
                    "type": 3,
                    "custom_id": "class_select_1",
                    "options":[
                        {
                            "label": "Rogue",
                            "value": "rogue",
                            "description": "Sneak n stab",
                            "emoji": {
                                "name": "rogue",
                                "id": "625891304148303894"
                            }
                        },
                        {
                            "label": "Mage",
                            "value": "mage",
                            "description": "Turn 'em into a sheep",
                            "emoji": {
                                "name": "mage",
                                "id": "625891304081063986"
                            }
                        },
                        {
                            "label": "Priest",
                            "value": "priest",
                            "description": "You get heals when I'm done doing damage",
                            "emoji": {
                                "name": "priest",
                                "id": "625891303795982337"
                            }
                        }
                    ],
                    "placeholder": "Choose a class",
                    "min_values": 1,
                    "max_values": 3
                }
            ]
        }"#;

        let res = serde_json::from_str::<Component>(json);

        assert!(res.is_ok());

        let component = res.unwrap();

        println!("{:#?}", component);
    }
}
